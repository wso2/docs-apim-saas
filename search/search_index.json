{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"administer/inviting-members/","title":"Inviting members","text":""},{"location":"administer/inviting-members/#inviting-users","title":"Inviting users","text":"<p>An organization administrator can invite users to the organization by assigning them specific groups. Invited users receive an invitation via email. An invited user must accept the invitation to join the organization and access the resources of that organization.</p>"},{"location":"bijira-concepts/ci-cd/","title":"CI/CD","text":"<p> Bijira provides a streamlined continuous integration and continuous deployment (CI/CD) experience to deploy applications and services efficiently across multiple environments.</p> <p>Bijira creates environments for each project, where all components within the project share the environments. An environment is an isolated deployment area with restricted network and resource access. Services deployed in one environment cannot communicate with services deployed in another.</p> <p>The Bijira cloud data plane provides two default environments (i.e., development and production). However, if you are in a private data plane organization, you can customize and create multiple environments based on your requirements.</p> <p>Bijira adopts a build once, deploy many strategy to manage components across multiple environments. An application is built only once (i.e., per commit if automatic build on commit is enabled or based on the selected commit during a manual build). Then it is promoted to subsequent environments. This allows testing changes in lower, non-production environments like development before promoting the build to production.</p> <p>Bijira injects configurations and secrets that you maintain at the environment level into components at runtime. This ensures a strict separation of environment-specific configurations from source code. Although configurations can vary across environments, the code and the built container remain unchanged. Configurations and secrets include:</p> <ul> <li>Resource credentials to a database, cache, or other backing services.</li> <li>Credentials to external cloud services such as Amazon S3 or external APIs.</li> </ul> <p>All configurations and secrets are encrypted at rest and in transit and stored in a secure vault. In a private data plane organization, you can store configurations and secrets in your infrastructure.</p>"},{"location":"bijira-concepts/ci-cd/#build","title":"Build","text":"<p>Bijira auto-generates build pipelines that may slightly differ depending on the component type you create. Generally, all build pipelines work as follows:</p> <ul> <li>Builds a container image either from the provided source code or from a given Dockerfile for a specific commit.</li> <li>Runs security and vulnerability scans if applicable, depending on the component type.</li> <li>Pushes the container image to a container registry. In the cloud data plane, Bijira pushes the image to a Bijira-managed registry. If it is a private data plane organization, Bijira pushes the image to a registry that you own.</li> <li>Updates service endpoints and API specifications from the provided repository if applicable.</li> </ul>"},{"location":"bijira-concepts/ci-cd/#repeatable-builds","title":"Repeatable builds","text":"<p>Bijira can replicate builds from an identical code version (Git commit). This means that multiple builds initiated from the same Git commit will generate Docker images with the same behavior.</p> <p>Note</p> <p>In the event of multiple builds from the same code version, Bijira preserves only the most recent version of the Docker image created from the particular code version.</p>"},{"location":"bijira-concepts/ci-cd/#trigger-a-build","title":"Trigger a build","text":"<p>On the Build page, click Build Latest. If necessary, you have the option to select a particular commit and build an image.</p> <p>Note</p> <p>Admin and Bijira DevOps users can trigger builds using specific tags from the connected Git repository. However, this action bypasses the standard branch-based deployment process and should only be used for critical, time-sensitive scenarios, as it can disrupt deployment track integrity.</p> <p>If you want to automatically trigger a build with each commit, you can enable Auto Build on Commit.</p>"},{"location":"bijira-concepts/ci-cd/#build-logs","title":"Build logs","text":"<p>You can view build logs for specific builds on the Build page.</p> <p>To view details of a specific build, click View Details corresponding to the build.</p>"},{"location":"bijira-concepts/ci-cd/#deployment","title":"Deployment","text":"<p>Once you build an image in Bijira, you can deploy it via the Deploy page. To deploy an image, you can follow one of the approaches given below:</p> <ul> <li>Manually deploy: In the Deploy page, go to the Set Up card and click Deploy.</li> <li>Automatically deploy on build: In the Deploy page, go to the Set Up card and enable Auto Deploy on Build. This automatically initiates deployment upon the completion of an automatic build.</li> </ul> <p>Info</p> <p>To enable Auto Deploy on Build, you must enable Auto Build on Commit. This is because automatic deployment is not necessary or useful in scenarios where automatic build is not enabled.</p> <p>Note</p> <ul> <li>You must trigger the first build in a Ballerina component manually to ensure that Bijira applies the required configurations to the development environment. You can enable automatic builds subsequently.</li> <li>Bijira automatically checks the configurable defined in your source code against the configurable values applied in an environment. Bijira requests the configurable values on deployment and promotion. If you have changed the configurables in your Ballerina component, auto-build pipelines can fail as a precaution to avoid a component crash at runtime due to missing configurables.</li> <li>The configurable verifying capability is only available for Ballerina components. For Dockerfile-based components, ensure to manage and update the configurations and secrets in environments ahead of time. You must also ensure backward compatibility between at least one release if you change the configurations.</li> </ul>"},{"location":"bijira-concepts/ci-cd/#set-up-area-and-initial-deployment","title":"Set up area and initial deployment","text":"<p>In the deploy phase, Bijira uses a setup area to merge the Docker image with its environment-independent configurations. Bijira then deploys this composite to the environment. This is known as the initial deployment.</p>"},{"location":"bijira-concepts/ci-cd/#immutable-deployments","title":"Immutable deployments","text":"<p>Once Bijira deploys a component with configurations, the configurations become immutable. Any subsequent change results in a new deployment.</p>"},{"location":"bijira-concepts/ci-cd/#promote-a-component-to-a-higher-environment","title":"Promote a component to a higher environment","text":"<p>Bijira builds a container once per GitHub commit and then promotes it to subsequent higher environments.</p> <p>You can go to the Deploy page of a component and promote it manually across environments.</p>"},{"location":"bijira-concepts/ci-cd/#configurations","title":"Configurations","text":"<p>Bijira allows you to define both environment-independent configurations and environment-specific configurations.</p>"},{"location":"bijira-concepts/ci-cd/#environment-independent-configurations","title":"Environment-independent configurations","text":"<p>These configurations apply to all environments.</p> <p>To change environment-independent configurations, go to the Deploy page of the component, make the necessary configuration changes via the Set Up card, and then trigger a new deployment to the initial environment. From there, you can proceed to promote the component to higher environments.</p>"},{"location":"bijira-concepts/ci-cd/#environment-specific-configurations","title":"Environment-specific configurations","text":"<p>These configurations apply to a particular environment.</p> <p>To change environment-specific configurations, go to the Deploy page of the component, make the necessary configuration changes via the specific environment card, and trigger a new deployment.</p>"},{"location":"bijira-concepts/ci-cd/#task-execution","title":"Task execution","text":"<p>The information on the Execute page is only applicable to scheduled and manual task components.</p> <p>To track and monitor executions associated with a deployed scheduled task or manual task, go to the left navigation menu and click Execute.</p> <p>You can view current and historic execution details along with a quick snapshot of recent activity via the total count of executions within the last 30 days. For each execution, you can view vital details such as the unique execution ID, the time it was triggered, and relevant revision information. Furthermore, you can dive deeper into the details by clicking on a specific execution to access its associated logs. This information enhances transparency, troubleshooting capabilities, and overall execution management, allowing you to easily monitor and analyze workflows.</p>"},{"location":"bijira-concepts/ci-cd/#zero-downtime-deployments","title":"Zero-downtime deployments","text":"<p>Bijira performs rolling updates to ensure zero downtime between deployments and promotions.</p> <p>A new build undergoes a health check before traffic is switched to it from the current build.</p> <p>If you configure the necessary health checks for a component, it can prevent deploying and promoting unhealthy versions of a component.</p>"},{"location":"bijira-concepts/connections/","title":"Connections","text":"<p>Services can exist in two main forms: standalone and integrated. Connecting services is an integral part in creating integrated solutions. Bijira allows you to connect services using Connections. </p> <p>Using Connections, you can integrate the service you intend to deploy on Bijira with other services on Bijira or external resources. Upon creating a connection to a service on Bijira, Bijira provides you a Connection ID along with a set of connection parameters. Thereafter, you have the capability to configure your service to establish a connection using this Connection ID and map connection parameters to environment variable names in your Bijira component. You can read these environment variable names in your service implementation to retrieve the values, to create a programmatic connection to the service you want to consume. </p> <p>At runtime, Bijira dynamically injects values into the environment variables based on the configured mapping. This approach ensures that the connection parameter values and the service connection creation remain loosely coupled, providing developers with flexibility and ease of maintenance.</p> <p>You can add Connections in different visibility levels: Project and Component. The visibility levels are described below:</p>"},{"location":"bijira-concepts/connections/#project-connections","title":"Project Connections","text":"<p>Project Connections are Connections you create to connect to services within a particular project. The Connections can be used by any component within the project. </p> <p>For example, if you want to share a third-party service like Twilio across the project for all the components within that project to reuse, you can create a project connection. Components can refer to Project Connections using the connection ID.  Project connections created to consume Bijira services under the OAuth security scheme will share the same OAuth application across the project. Any component reusing such a connection will use the same client ID and client secret.</p>"},{"location":"bijira-concepts/connections/#component-connections","title":"Component Connections","text":"<p>Component Connections are Connections you define at the component level and used by only that component. </p> <p>For example, create a component connection if you want to connect a legacy service to a given component. Components can refer to the Component Connection using the connection ID.  If your component consumes more than one Bijira service, the Component connections created to consume those Bijira services under the OAuth security scheme can share the same OAuth application by sharing the same client ID and secret between all such connections.</p>"},{"location":"bijira-concepts/data-planes/","title":"Data Planes","text":"<p>Bijira's architecture comprises two key components: the control plane and the data plane. The control plane handles essential tasks such as administering organizations, users, and projects. In addition, it also governs the entire journey of application development, from the initial stages of creation, progressing  to deployment, including measures to enforce governance and the provision for observability. The Bijira control plane is a SaaS that manages all cloud data planes and private data planes. It caters to diverse user personas, including CIOs, architects, and developers, as well as DevOps, site reliability engineers, and platform engineers.</p> <p>The data plane is the environment where user applications are deployed based on configurations set in the control plane. These applications can range from services and web applications to APIs, integrations, and scheduled tasks. The applications can be written in various programming languages, allowing for a polyglot approach. Importantly, all traffic related to the runtime of user applications is restricted to the Bijira data plane, ensuring strict containment of user data within its boundaries.</p> <p>Bijira's architecture features two distinct data plane types: cloud data planes and private data planes. A cloud data plane utilizes a multi-tenanted infrastructure model for deploying user applications, creating a shared yet secure environment for application runtime. In contrast, a private data plane(PDP) provides dedicated infrastructure for a single organization to run its user applications. This ensures an added layer of privacy and control for organizations with specific requirements.</p> <p></p>"},{"location":"bijira-concepts/data-planes/#private-data-planes","title":"Private data planes","text":""},{"location":"bijira-concepts/data-planes/#infrastructure","title":"Infrastructure","text":"<p>Bijira private data planes can be deployed with almost all major cloud providers, such as Azure, AWS, and GCP, and are also compatible with on-premises infrastructure.</p> <p>The essential requirements for a private data plane include upstream-compatible Kubernetes clusters, a container registry, a key vault (secret store), and a logging service or log storage.</p> <p></p>"},{"location":"bijira-concepts/data-planes/#system-components","title":"System components","text":"<p>Setting up the Bijira PDP system involves using a Helm installation on the Kubernetes infrastructure.  The following software components are installed during the helm execution:</p> <ul> <li>Cilium CNI and service mesh.</li> <li>Bijira API Gateways and related components.</li> <li>Bijira PDP agent.</li> <li>Observability and logging APIs, along with observability agents.</li> <li>Flux controller.</li> </ul> <p>All of these software components receive automatic updates, including security patches and bug fixes through the flux controller connected to the Bijira Update Management System. </p>"},{"location":"bijira-concepts/data-planes/#connectivity-with-the-control-plane","title":"Connectivity with the control plane","text":"<p>The private data plane requires communication with the Bijira control plane to manage various activities. All these communications are outbound from the private data plane, ensuring that there is no need to open any specific <code>IP:Port</code> from its perspective for these interactions. However, if an organization's network restricts all outbound traffic, it is necessary to permit outbound traffic to the public IP range of the Bijira control plane.</p> <p>The following table outlines the inbound and outbound connections from a private data plane:</p> Data plane component Endpoint Direction Protocol Bijira PDP agent Bijira control plane (CP) (mizzen server) Outbound WSS Kubernetes API server Outbound (cluster internal) HTTPS, WS APIM/local adaptor Global adaptor Outbound HTTPS Azure Service Bus (CP) Outbound AMQP APIM/Enforcer Event hub (CP) Outbound AMQP Bijira secret resolver Cloud secret store Outbound (VPC internal) HTTPS Container registry Container registry (public) Inbound HTTPS Container registry Outbound (VPC internal) HTTPS Certificate manager Azure DNS service Outbound HTTPS LetsEncrypt Outbound HTTPS Flux source controller GitHub Outbound HTTPS Flux Helm controller Bijira container registry Outbound HTTPS <p>All communication between the control plane and the private data plane is secured using TLS.</p>"},{"location":"bijira-concepts/data-planes/#observability-architecture","title":"Observability architecture","text":"<p>The following diagram depicts the architecture overview of Bijira's in-data-plane log and observability in Azure PDP:</p> <p></p> <p>The private data plane observability architecture is centered around a strong commitment to data privacy and compliance. This is achieved through a strategic decision to retain logs and observability data within the data planes itself. Key aspects of this architecture include:</p> <ul> <li>Data storage at source: Logs and observability data are stored within the data plane itself, enhancing security, simplifying access, and ensuring compliance.</li> <li>Direct browser-to-data-plane interaction: The Bijira Console in the user's browser directly interacts with APIs in the data plane, reducing potential data routing complexities and ensuring a more secure, direct flow of information.</li> <li>Reduced data exposure points: Fetching data directly from the data plane's APIs minimizes the number of data transfer points, effectively decreasing the chances of data exposure or interception.</li> <li>Compliance with regulatory standards: The architecture supports data locality, aligning with global regulatory standards like GDPR and CCPA by keeping data in its original environment.</li> <li>Improved performance and real-time insights: Direct interaction between the browser and data plane results in faster data retrieval, providing users with immediate insights.</li> <li>User transparency and control: Users have a clear view of their data's location and access methods, alongside granular control over data access.</li> </ul>"},{"location":"bijira-concepts/data-planes/#security","title":"Security","text":"<p>The Bijira private data plane ensures extensive, production-grade security, ranging from infrastructure and architecture to zero-trust network security. All incoming traffic is protected by a firewall and must undergo authentication and authorization via the API Gateway. It also provides end-to-end network traffic encryption using Cilium transparent encryption, ensuring efficient data path encryption.</p>"},{"location":"bijira-concepts/data-planes/#management-models","title":"Management models","text":"<p>Bijira supports the following management models for private data planes (PDPs), fostering collaboration between WSO2 and customers across diverse scenarios:</p> <ul> <li>WSO2 fully managed (infrastructure and PDP in WSO2 subscription) model</li> <li>WSO2 fully managed (infrastructure and PDP in customer subscription) model</li> <li>Customer self-managed (WSO2 provides installation script and updates) model</li> </ul>"},{"location":"bijira-concepts/deployment-tracks/","title":"Deployment Tracks","text":"<p>Deployment Tracks in Bijira are structured pathways for simplified software component deployment. They act like advanced CI/CD pipelines, ensuring your components reach their destinations seamlessly, whether from source code or prebuilt images. They establish an organized and structured approach that minimizes the chances of errors and challenges that are typically associated with deployment workflows.</p>"},{"location":"bijira-concepts/deployment-tracks/#the-significance-of-deployment-tracks","title":"The significance of Deployment Tracks","text":"<p>Deployment Tracks offer practical solutions to enhance the API consumer experience by addressing two critical challenges:</p> <ul> <li> <p>Streamlined deployment: Deployment Tracks serve as well-designed routes for your software components, enhancing the organization and reliability of the deployment process, similar to a well-structured express route.</p> </li> <li> <p>Efficient API versioning: Especially beneficial for managed APIs, Deployment Tracks provide a straightforward method for creating API versions that seamlessly interact with previous iterations. This simplified version management benefits both API creators and consumers alike.</p> </li> </ul>"},{"location":"bijira-concepts/deployment-tracks/#streamlined-deployments","title":"Streamlined deployments","text":"<p>For streamlined deployments, Bijira dissects two integral approaches that leverage Deployment Tracks: the comprehensive CI/CD integration and the focused CD-Only strategy.</p>"},{"location":"bijira-concepts/deployment-tracks/#cicd-with-deployment-tracks","title":"CI/CD with Deployment Tracks","text":"<p>A deployment track is linked to a particular branch within a GitHub repository. This connection is useful for handling deployments to various environments. On Bijira's Deploy page, you can easily visualize the deployments to specific environments associated with your selected deployment track. Moreover, the deployment track has a functionality that initiates automatic deployments for the linked branch. When activated, merging a pull request (PR) triggers a deployment to the development environment.</p> <p></p>"},{"location":"bijira-concepts/deployment-tracks/#cd-only-strategy-with-deployment-tracks","title":"CD-Only strategy with Deployment Tracks","text":"<p>If you're inclined to use your own Continuous Integration (CI) systems and want to harness the deployment track as a Continuous Deployment (CD) pipeline, you can seamlessly link deployment tracks to a container registry repository. This configuration empowers users to effortlessly deploy images sourced directly from the linked container registry repository.</p> <p></p>"},{"location":"bijira-concepts/deployment-tracks/#efficient-api-versioning","title":"Efficient API versioning","text":"<p>This section applies to only service components. When working with service components in Bijira, it is important to have an effective API versioning mechanism. Bijira follows a versioning mechanism based on Semantic Versioning (SemVer) but only includes the major version and minor version with the prefix <code>v</code>. </p> <p>For example, <code>v1.2</code>. </p> <p>You can follow the approach given below when you version APIs in Bijira:</p> <ul> <li>Increment the major version when you make incompatible API changes.</li> <li>Increment the minor version when you add functionality in a backward-compatible manner.</li> </ul> <p>What is Semantic Versioning?</p> <p>Semantic Versioning (SemVer) is a specification that defines how to assign and increment version numbers for software products, including APIs. For more information, see Semantic Versioning specification.</p> <p>One of the primary concerns when dealing with SaaS APIs is to minimize disruption for API consumers while continuously developing and deploying updates.</p> <p>In compliance with SemVer, changes that don't introduce breaking or additive modifications to the API are categorized as patch updates. Hover, from the perspective of API consumers, these changes should ideally not disrupt their API clients. Typically, API consumers are most concerned with major API version alterations, but there might be instances where minor version changes are communicated to them.</p> <p>Therefore, in the context of deployment tracks, API developers only need to specify the major and minor versions being delivered from a particular deployment track. This information is treated as the API version attribute of a deployment track. If the publisher requires versioning for internal tracking purposes, this can be accomplished in Git through the use of Git tags, on GitHub with GitHub releases, and so forth.</p> <p></p>"},{"location":"bijira-concepts/organization/","title":"Organization","text":"<p>An organization in Bijira is a logical grouping of users and user resources. A first-time user must create an organization and be a member of it when signing in to Bijira. Users and resources in an organization cannot access resources in another organization unless an admin of the other organization invites them and adds them as a member of that organization. A user cannot create more than one organization.</p>"},{"location":"bijira-concepts/organization/#switch-organizations","title":"Switch organizations","text":"<p>If you are a member of more than one organization, you can switch from one organization to another when necessary. To do this, select the required organization from the Organization list in the Bijira Console header.</p>"},{"location":"bijira-concepts/organization/#inviting-users","title":"Inviting users","text":"<p>An organization administrator can invite users to the organization by assigning them specific groups. Invited users receive an invitation via email. An invited user must accept the invitation to join the organization and access the resources of that organization.</p>"},{"location":"bijira-concepts/organization/#manage-user-permission","title":"Manage user permission","text":"<p>Bijira manages user permissions with groups and roles.</p>"},{"location":"bijira-concepts/organization/#groups","title":"Groups","text":"<p>A group in Bijira is a collection of users, each with one or more roles assigned to them. Users within a group inherit the permissions associated with the roles assigned to that group. For instance, if a user is added to the <code>API Publisher</code> group, they will automatically receive the <code>API Publisher</code> role.</p> <p>Bijira comes with predefined groups already configured with specific roles, as follows:</p> <ul> <li>API Publisher: A collection of users who have the API Publisher role.</li> <li>API Subscriber: A collection of users who have the API Subscriber role.</li> <li>Admin : A collection of users who have the Admin role.</li> <li>Billing Admin : A collection of users who have the Billing Admin role.</li> <li>Bijira DevOps : A collection of users who have the Bijira DevOps role.</li> <li>Developer : Users who develop, deploy, and manage cloud native applications at scale.</li> <li>External API Subscriber: A collection of users who have the External API Subscriber role.</li> </ul> <p>When creating a new group to invite members, be sure to assign a role to the group to ensure users have the required permissions.</p>"},{"location":"bijira-concepts/organization/#roles","title":"Roles","text":"<p>Bijira roles are defined as follows:</p> <ul> <li>API Publisher: An API publisher can discover, create, publish, delete, test, and manage an API.</li> <li>API Subscriber: An API subscriber is a developer in a particular organization. An API subscriber can subscribe to an application, manage subscriptions, manage applications, generate API keys, and manage API keys.</li> <li>Admin: An administrator is responsible for all administration tasks, including user management, customizing the Developer Portal, managing projects, enabling analytics, managing domains, etc.</li> <li>Billing Admin: Is responsible for billing administration that includes viewing tiers, creating and viewing organizations, managing invoices, viewing and creating subscriptions, and viewing and creating payment methods.</li> <li>Bijira DevOps: A Bijira DevOps user is a user with access to the Bijira DevOps portal, enabling them to actively manage, ensure dependable deployment, and monitor components.</li> <li>Developer : A user who can develop, deploy, and manage cloud native applications at scale.  </li> <li>External API subscriber: External API subscribers are API consumers who have access only to the API Developer Portal. They can join an organization with the sole purpose of consuming APIs.</li> <li>Environment Manager (Deprecated): Manages deployment environments.</li> </ul>"},{"location":"bijira-concepts/organization/#organization-id","title":"Organization ID","text":"<p>The Organization ID serves as a unique identifier for each organization. To get the organization ID, follow the steps below:</p> <ol> <li>Go to https://console.bijira.dev/ and sign in. This opens the project home page.</li> <li>Click on the Organization list on the header and select your organization.</li> <li>In the left navigation, click Settings.</li> <li>In the header, click the Organization list. This will open the organization level settings page. </li> <li>Under Organization click Copy ID.</li> </ol>"},{"location":"bijira-concepts/organization/#organization-handle","title":"Organization Handle","text":"<p>The organization handle is a unique string that directly corresponds to your organization's name. To get the organization handle, follow the steps below:</p> <ol> <li>Go to https://console.bijira.dev/ and sign in. This opens the project home page.</li> <li>Click on the Organization list on the header and select your organization.</li> <li>In the left navigation, click Settings.</li> <li>Under Organization click Copy Handle.</li> </ol>"},{"location":"bijira-concepts/project/","title":"Project","text":"<p>A project in Bijira is a logical group of related components that typically represent a single cloud native application. A project consists of one or more components. All components within a project can ideally be (but is not restricted to) in a single GitHub repository under different paths. This is also known as the monorepo architecture.</p> <p>At deployment time, all components within a given project are deployed into a single namespace of the Kubernetes cluster. Components within a project can be exposed to the public internet, internally to the rest of the organization, or privately within the project only. A project in Bijira is represented as a cell with regard to the Cell-based architecture. The following diagram illustrates a project and how the components within a project are laid out at runtime:</p> <p></p>"},{"location":"create-api-proxy/overview/","title":"Overview","text":"<p>Bijira API Manager allows you to create API proxies that can be used to secure, protect, and manage access to your APIs. You can create an API proxy by defining a set of policies and behaviors that control how the API proxy interacts with the backend service.</p> <p>An API proxy can be used to expose an existing API which is hosted in same organization or a third party API.</p> <p>Creating an API proxy for:</p> <ul> <li> <p>My APIs(Ingress APIs)</p> <p>An API Proxy can be created to front an existing ingress api in following scenarios:</p> <ul> <li>Import API Contract</li> <li>Start with Endpoint</li> <li>Start from Scratch </li> <li>Create with GenAI</li> </ul> </li> <li> <p>Third Party APIs(Egress APIs)</p> <p>An API Proxy can be created to front an Endpoint or API which is managed by a third party in following scenarios:</p> <ul> <li>Get from Marketplace</li> <li>Import API Contract</li> <li>AI APIs</li> </ul> </li> </ul>"},{"location":"create-api-proxy/my-apis/create-with-genai/","title":"Create API with Generative AI","text":""},{"location":"create-api-proxy/my-apis/import-api-contract/","title":"Import API Contract","text":"<p>An API proxy acts as an intermediary between an existing API and Bijira, intercepting all requests made to the API.It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.</p> <p>In this guide, you will:</p> <ul> <li>Create an API proxy.</li> <li>Configure and Deploy the API proxy.</li> <li>Test the API proxy to verify its functionality.</li> </ul>"},{"location":"create-api-proxy/my-apis/import-api-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>A valid Bijira account with available resource quota.</li> </ul>"},{"location":"create-api-proxy/my-apis/import-api-contract/#create-an-api-proxy","title":"Create an API Proxy","text":"<p>In this guide, you will specify a URL to an OpenAPI definition of a sample API to create an API proxy.</p> <ol> <li>Go to https://console.bijira.dev/ and sign in. This opens the project home page.</li> <li>Select Import API Contract.</li> <li>Select URL option and provide the following URL to import the API contract from the GitHub repository:    <pre><code>https://raw.githubusercontent.com/wso2/bijira-samples/refs/heads/main/reading-list-api/open-api.yaml\n</code></pre></li> <li>Click Next and edit pre-defined values as needed. You can keep the default values for this sample.</li> <li>Click Create to create the API Proxy. Wait for the setup to complete.</li> </ol>"},{"location":"create-api-proxy/my-apis/import-api-contract/#configure-and-deploy-the-api-proxy","title":"Configure and Deploy the API Proxy","text":"<ol> <li>Navigate to the Deploy page of the API Proxy.</li> <li>Select Configure and Deploy option from the Deploy dropdown and click Configure and Deploy button.</li> <li>Select External as API Access Mode.</li> <li>Click Deploy.</li> </ol>"},{"location":"create-api-proxy/my-apis/import-api-contract/#test-the-api-proxy","title":"Test the API Proxy","text":"<ol> <li>Navigate to the Test \u2192 OpenAPI Console page of the API Proxy.</li> <li>Use the OpenAPI Console to test the API Proxy.</li> </ol>"},{"location":"create-api-proxy/my-apis/import-api-contract/#api-proxy-behavior","title":"API Proxy Behavior","text":"<p>The Reading List API Proxy provides the following functionality:</p> <ul> <li>GET /books: Returns a list of pre-defined books with a warning that changes are not persisted.</li> <li>POST /books: Adds a new book to the reading list (without including <code>id</code> in the request body). Returns the created book along with a warning that changes are not persisted.</li> <li>PUT /books/{id}: Updates the status of an existing book. The request body only includes the <code>status</code> to update, and the <code>id</code> is passed in the URL. Returns the updated book with a warning.</li> <li>GET /books/{id}: Retrieves a book by its <code>id</code>. If the <code>id</code> does not exist, a 404 error is returned.</li> <li>DELETE /books/{id}: Deletes a book by its <code>id</code>.</li> </ul>"},{"location":"create-api-proxy/my-apis/start-from-scratch/","title":"Create API Proxy from Scratch","text":""},{"location":"create-api-proxy/my-apis/start-with-endpoint/","title":"Create API proxy from Start with Endpoint","text":""},{"location":"create-api-proxy/third-party-apis/ai-apis/","title":"AI APIs","text":""},{"location":"create-api-proxy/third-party-apis/get-from-marketplace/","title":"Get API from Marketplace","text":""},{"location":"create-api-proxy/third-party-apis/import-api-contract/","title":"Import Egress API Contract","text":""}]}